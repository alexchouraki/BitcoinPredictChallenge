---
title: "Super projet BTC-NLP"
output: html_notebook
---

```{r}
library(lubridate)
library(tidyverse)
```

# Principes généraux

Le but de l'exercice est d'essayer de prédire l'évolution du cours du Bitcoin.

- Ici, on se concentrera uniquement sur la variable binaire "Est-ce que le bitcoin a monté ou a baissé entre deux journées" ?

- On ne se souciera donc pas de *quantifier* la prédiction de hausse ou de baisse du bitcoin.

Pour cela, plusieurs idées possibles :

- Utiliser les données Google Trends pour voir un peu les tendances haussières / baissières

- Faire du NLP sur les forums de Bitcoin (sentiment analysis ?)

- Essayer de faire une analyse technique financière d'après le Bitcoin


# Retrieve the Bitcoin data

For information, the file `bitcoin_price.csv` has been downloaded from Coindesk ([available here](https://www.coindesk.com/price/)).

```{r}
bitcoin.data = read.csv("./data/bitcoin_price.csv")
```

## Cleaning the data a bit

```{r}
bitcoin.data = bitcoin.data %>% filter(!is.na(Close.Price)) # Remove the last two lines
```

```{r}
bitcoin.data$Date = bitcoin.data$Date %>% # Remove the time from the date
  sapply(as.character) %>%
  sapply(substr, 1, 10)

bitcoin.data$Date = ymd(bitcoin.data$Date) # Transform the date from string into a lubridate
```

## Generate the binary variable we need to predict

```{r}
binary.variable = rep(NA, nrow(bitcoin.data) - 1)

for(i in c(1:(nrow(bitcoin.data) - 1))){
  
  if(bitcoin.data$Close.Price[i] > bitcoin.data$Close.Price[i+1]){
    
    binary.variable[i] = "Down"
    
  } else {binary.variable[i] = "Up"}
  
}


bitcoin.data = bitcoin.data %>% filter(Date != ymd("2015-12-31"))
```

```{r}
bitcoin.data$Trend = binary.variable
```

## Result: data that is clean, with the proper variable to predict
```{r}
colnames(bitcoin.data) = c('date', 'close.price', 'trend')
```

```{r}
ggplot(data = bitcoin.data,
       aes(x = Date, y = Close.Price)) +
  geom_line()
```

# Données regroupées
```{r}
NLP_data = read.csv('./data/NLP_grouped_data.csv')
NLP_data
```

## Reformater la date
```{r}
NLP_data$date = NLP_data$date %>% # Remove the time from the date
  sapply(as.character)

NLP_data$date = ymd(NLP_data$date)
```

## Join
```{r}
full_data = inner_join(NLP_data, bitcoin.data)
full_data$trend = as.factor(full_data$trend)
```

## Split by training and testing data
```{r}
train_data = full_data %>% filter(date < ymd('2017/01/05') | date > ymd('2018/01/05'))
test_data = full_data %>% filter(date >= ymd('2017/01/05') & date <= ymd('2018/01/05'))
```

## Dummy classifier
```{r}
max(sum(test_data$trend == "Up"), sum(test_data$trend == "Down")) / nrow(test_data)
```


## Logistic regression
```{r}
reg.model = glm(trend ~ date + polarity + log_merit + post + polarity_and_log_merit, family = "binomial", data = train_data)
summary(reg.model)
```

```{r}
reg.predict = predict(reg.model, test_data, type = "response")
reg.prediction = prediction(reg.predict, test_data$trend)
reg.perf = performance(reg.prediction, measure = "tpr", x.measure = "fpr")
plot(reg.perf)
```

```{r}
reg.auc = performance(reg.prediction, measure = "auc")
reg.auc = reg.auc@y.values[[1]]
reg.auc
```

```{r}
prediction_vector = rep(NA, nrow(test_data))
prediction_vector[predict(reg.model, test_data, type = "response") > 0.5] = "Up"
prediction_vector[is.na(prediction_vector)] = "Down"

sum(prediction_vector == test_data$trend) / nrow(test_data)
```

## Random Forest

```{r}
set.seed(0)
rf.model = randomForest(trend ~ date + polarity + log_merit + post + polarity_and_log_merit, data = train_data)
```

```{r}
sum(predict(rf.model, test_data, type = "response") == test_data$trend) / nrow(test_data)
```



# Quelques réflexions sur des pistes à suivre

## Analyse technique sur le cours
Pas facile à implémenter, d'autant plus que je pense qu'une des suppositoins, c'est que nos prédictions sont indépendantes (i.e. la prédiction pour le jour j doit être indépendante de celle pour le jour j+1 ou celle pour le jour j-1).

A voir si on a le droit d'utiliser les données "déjà passées" pour faire des prédictions futures (i.e. si on veut faire une prédiction pour le 10 mai, est-ce qu'on a le droit d'utiliser le cours du 1 au 9 mai ?)

## Google Trends
Piste intéressante. Mais problème : à partir d'un certain stade, les données Google Trends s'obtiennent par semaine, et plus par jour, donc on n'a plus grand chose d'exploitable.

```{r}
trends = read.csv('./data/trends.csv')
trends$date = ymd(trends$date)
```

### Graphe correspondant (exemple Bitcoin)

```{r}
ggplot(data = trends,
       aes(x = date, y = cryptocurrency)) +
  geom_line()
```

# Modélisation
```{r}
library(ROCR)
library(randomForest)
```

## On réunit les datasets pour former un truc complet
```{r}
trend.data = data.frame(trends, "bitcoin.value" = bitcoin.data$Close.Price, "bitcoin.trend" = bitcoin.data$Trend)
trend.data
```


### Split entre training et test dataset
```{r}
set.seed(0)
train.sample = c(1:nrow(trend.data)) %in% sample(c(1:nrow(trend.data)), as.integer(nrow(trend.data) * 0.8))
train.trend = trend.data[train.sample,]
test.trend = trend.data[!train.sample,]
```

## Quelle précision de base ?
```{r}
max(sum(test.trend$bitcoin.trend == "Up"), sum(test.trend$bitcoin.trend == "Down")) / nrow(test.trend)
```

La précision du dummy model (qui prédit toujours la même chose) sera donc de $51.3\%$.

## Premier modèle tout con : régression logistique
```{r}
reg.model = glm(bitcoin.trend ~ date + bitcoin + btc + hodl + blockchain, family = binomial, data = train.trend)
```

```{r}
reg.predict = predict(reg.model, test.trend, type = "response")
reg.prediction = prediction(reg.predict, test.trend$bitcoin.trend)
reg.perf = performance(reg.prediction, measure = "tpr", x.measure = "fpr")
plot(reg.perf)
```

```{r}
reg.auc = performance(reg.prediction, measure = "auc")
reg.auc = reg.auc@y.values[[1]]
reg.auc
```

## Autre type de modèle : Random forest
```{r}
set.seed(0)
rf.model = randomForest(bitcoin.trend ~ date + bitcoin + btc + hodl + blockchain, mtry = 3, data = train.trend)
```

```{r}
sum(predict(rf.model, test.trend, type = "response") == test.trend$bitcoin.trend) / nrow(test.trend)
```


